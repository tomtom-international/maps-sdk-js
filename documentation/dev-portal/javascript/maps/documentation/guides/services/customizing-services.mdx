---
title: Customizing services
hideMenu: false
hideSubmenu: false
hasTwoColumns: false
titleTags:
- label: "VERSION 0.9.3"
  color: "grey5"
- label: "PRIVATE PREVIEW"
  color: "grey5"
---

# Customizing Services

The TomTom Maps SDK provides extensive configuration options to customize service behavior, optimize performance, and handle different application requirements. This guide covers request validation, custom configurations, error handling, and advanced service customization techniques.

## Request Validation

The SDK includes built-in request validation that verifies each service request adheres to the expected structure before sending it to the API. This validation system helps developers catch errors early and prevents faulty API calls that could result in unnecessary costs.

**Benefits of Request Validation:**
- Contextual error messages relevant to SDK types (easier debugging)
- Prevention of malformed API calls (cost optimization)
- Early error detection in development

**Performance Considerations:**
If you're confident about your inputs and want to optimize CPU usage, you can disable validation on a per-service basis:

```javascript
import { search, geocode, calculateRoute } from '@cet/maps-sdk-js/services';

// Disable validation for specific services
await search({
    query: "Eiffel Tower",
    validateRequest: false
});

await geocode({
    query: "Amsterdam",
    validateRequest: false
});
```

**Recommendation:** Keep validation enabled during development and testing phases. Only disable it in production when you're confident about input quality.

## Global Service Configuration

The `TomTomConfig` class provides centralized configuration management for all SDK services. This approach ensures consistent behavior across your application and simplifies configuration management.

```javascript
import { TomTomConfig } from '@cet/maps-sdk-js/core';

TomTomConfig.instance.put({
    apiKey: 'YOUR_API_KEY',
    language: 'en-GB',                    // Default language for all responses
    baseUrl: 'https://api.tomtom.com',    // Custom API base URL for enterprise
    timeout: 10000,                       // Global request timeout (milliseconds)
    validateRequest: false                // Global validation setting
});
```

**Configuration Options:**
- **apiKey**: Your TomTom API key (required)
- **language**: ISO language code for response localization
- **baseUrl**: Custom endpoint for enterprise or regional deployments
- **timeout**: Maximum request duration before timeout
- **validateRequest**: Global validation toggle

## Service-Specific Headers

For advanced use cases, you can add custom headers to individual service requests. This is useful for tracking, authentication extensions, or custom API routing:

```javascript
await search({
    query: "restaurants",
    position: [4.9041, 52.3676],
    headers: {
        'Custom-Header': 'custom-value',
        'User-Agent': 'MyApp/1.0',
        'X-Request-ID': 'unique-request-id'
    }
});
```

## Comprehensive Error Handling

Robust error handling is crucial for production applications. The SDK provides structured error responses that help you implement appropriate user feedback and fallback strategies:

```javascript
import { search } from '@cet/maps-sdk-js/services';

try {
    const results = await search({
        query: "coffee",
        position: [4.9041, 52.3676]
    });

    console.log(results.results);
} catch (error) {
    // Handle specific error types
    if (error.status === 401) {
        console.error('Authentication failed: Invalid API key');
        // Redirect to configuration or show API key setup
    } else if (error.status === 429) {
        console.error('Rate limit exceeded: Too many requests');
        // Implement exponential backoff retry logic
    } else if (error.status === 400) {
        console.error('Bad request: Invalid parameters');
        // Show user-friendly validation messages
    } else {
        console.error('Service error:', error.message);
        // Implement fallback or retry logic
    }
}
```

**Common Error Codes:**
- **400**: Bad Request - Invalid parameters or malformed request
- **401**: Unauthorized - Invalid or missing API key
- **403**: Forbidden - API key lacks required permissions
- **429**: Too Many Requests - Rate limit exceeded
- **500**: Internal Server Error - Service temporarily unavailable

## Custom Timeouts and Retry Logic

Different services may require different timeout configurations based on complexity and expected response times:

```javascript
// Short timeout for autocomplete (fast response expected)
await autocompleteSearch({
    query: "coffee",
    position: [4.9041, 52.3676],
    timeout: 3000 // 3 seconds
});

// Longer timeout for complex routing calculations
await calculateRoute({
    locations: [[4.9041, 52.3676], [2.3522, 48.8566]],
    timeout: 15000 // 15 seconds
});
```

## Environment-Specific Configuration

Configure different settings for development, staging, and production environments:

```javascript
const config = {
    development: {
        apiKey: process.env.TOMTOM_DEV_API_KEY,
        timeout: 30000,
        validateRequest: true,
        baseUrl: 'https://api.tomtom.com'
    },
    production: {
        apiKey: process.env.TOMTOM_PROD_API_KEY,
        timeout: 10000,
        validateRequest: false,
        baseUrl: 'https://api.tomtom.com'
    }
};

TomTomConfig.instance.put(config[process.env.NODE_ENV] || config.development);
```

## Service Templates and Customization

The SDK follows a consistent service template pattern that allows for advanced customization. Each service implementation consists of four main steps:

1. **Request Validation**: Validates input parameters against expected schema
2. **API Request Building**: Transforms SDK parameters to API-compatible format
3. **Request Execution**: Handles HTTP communication with proper headers and error handling
4. **Response Parsing**: Converts API responses to SDK-compatible types

This architecture enables you to customize any part of the service flow while maintaining compatibility with the rest of the SDK.

For complete examples and advanced customization patterns, check the `/examples` folder in the repository.
