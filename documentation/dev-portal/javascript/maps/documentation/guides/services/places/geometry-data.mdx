---
title: Geometry data
hideMenu: false
hideSubmenu: false
hasTwoColumns: false
titleTags:
- label: "VERSION 0.9.3"
  color: "grey5"
- label: "PRIVATE PREVIEW"
  color: "grey5"
---

# Geometry Data Service

The Geometry Data service retrieves detailed boundary geometries for places, enabling you to display precise geographic boundaries for countries, regions, cities, neighborhoods, and other geographic areas on your maps.

## Basic Usage

```javascript
import { geometryData } from '@cet/maps-sdk-js/services';
import { geocode } from '@cet/maps-sdk-js/services';

// First, get a place from geocoding or search
const place = await geocode({ query: 'Amsterdam, Netherlands' });

// Then fetch its geometry data
const geometry = await geometryData({
    geometries: place,
    zoom: 10 // Appropriate zoom level for the geometry detail
});

console.log(geometry.type); // "FeatureCollection"
console.log(geometry.features[0].geometry.type); // "Polygon" or "MultiPolygon"
```

## Integration with Map Module

Display place boundaries on your map:

```javascript
import { geometryData } from '@cet/maps-sdk-js/services';
import { GeometriesModule } from '@cet/maps-sdk-js/map';

// Get place and its geometry
const place = await geocode({ query: 'Central Park, New York' });
const boundaries = await geometryData({ geometries: place, zoom: 15 });

// Display on map
const geometriesModule = await GeometriesModule.init(map);
geometriesModule.show(boundaries);

// Fit map to boundaries
if (boundaries.bbox) {
    map.mapLibreMap.fitBounds(boundaries.bbox);
}
```

## Zoom-Level Optimization

Different zoom levels return different levels of detail:

```javascript
// Low detail for country/region level
const countryBoundary = await geometryData({
    geometries: place,
    zoom: 5
});

// Medium detail for city level
const cityBoundary = await geometryData({
    geometries: place,
    zoom: 10
});

// High detail for neighborhood level
const detailedBoundary = await geometryData({
    geometries: place,
    zoom: 15
});
```

## Working with Multiple Geometries

Process multiple places at once:

```javascript
// Get multiple places
const places = await search({
    query: 'parks',
    position: [4.9041, 52.3676],
    limit: 5
});

// Get geometries for all places
const allGeometries = await geometryData({
    geometries: places,
    zoom: 14
});

// Display all boundaries
geometriesModule.show(allGeometries);
```

## Advanced Styling Options

Customize how boundaries appear on the map:

```javascript
const geometriesModule = await GeometriesModule.init(map, {
    fillConfig: {
        fillColor: '#87CEEB',
        fillOpacity: 0.3
    },
    lineConfig: {
        lineColor: '#4169E1',
        lineWidth: 2,
        lineOpacity: 0.8
    }
});

const boundaries = await geometryData({ geometries: place, zoom: 12 });
geometriesModule.show(boundaries);
```

## Use Cases

### Administrative Boundaries
Display country, state, or city boundaries:

```javascript
const displayAdminBoundaries = async (placeName, zoomLevel = 8) => {
    try {
        const place = await geocode({ query: placeName });

        if (place.features.length > 0) {
            const boundaries = await geometryData({
                geometries: place,
                zoom: zoomLevel
            });

            geometriesModule.show(boundaries);

            // Fit map to show the entire boundary
            if (boundaries.bbox) {
                map.mapLibreMap.fitBounds(boundaries.bbox, { padding: 50 });
            }
        }
    } catch (error) {
        console.error('Failed to display boundaries:', error);
    }
};

// Display Netherlands boundaries
await displayAdminBoundaries('Netherlands', 6);
```

### Service Area Visualization
Show delivery or service coverage areas:

```javascript
const showServiceAreas = async (locations) => {
    const serviceAreas = [];

    for (const location of locations) {
        const place = await geocode({ query: location.address });

        if (place.features.length > 0) {
            const geometry = await geometryData({
                geometries: place,
                zoom: 12
            });

            serviceAreas.push({
                ...location,
                boundary: geometry
            });
        }
    }

    // Display all service areas
    serviceAreas.forEach(area => {
        geometriesModule.show(area.boundary);
    });

    return serviceAreas;
};
```

### Geographic Analysis
Compare sizes and overlaps of different areas:

```javascript
const compareAreas = async (placeNames) => {
    const areas = {};

    for (const name of placeNames) {
        const place = await geocode({ query: name });

        if (place.features.length > 0) {
            const geometry = await geometryData({
                geometries: place,
                zoom: 8
            });

            areas[name] = {
                geometry,
                bbox: geometry.bbox,
                area: calculateArea(geometry) // Custom area calculation
            };
        }
    }

    return areas;
};

const areas = await compareAreas(['Texas', 'California', 'Alaska']);
```

## Performance Considerations

### Appropriate Zoom Levels
Choose zoom levels based on your use case:

```javascript
const getOptimalZoom = (areaType) => {
    const zoomLevels = {
        'country': 4,
        'state': 6,
        'region': 8,
        'city': 10,
        'district': 12,
        'neighborhood': 14,
        'detailed': 16
    };

    return zoomLevels[areaType] || 10;
};

const geometry = await geometryData({
    geometries: place,
    zoom: getOptimalZoom('city')
});
```

### Caching Geometries
Cache frequently used boundaries:

```javascript
class GeometryCache {
    constructor() {
        this.cache = new Map();
    }

    getCacheKey(placeId, zoom) {
        return `${placeId}-${zoom}`;
    }

    async getGeometry(place, zoom) {
        const placeId = place.features[0]?.properties.id;
        const key = this.getCacheKey(placeId, zoom);

        if (this.cache.has(key)) {
            return this.cache.get(key);
        }

        const geometry = await geometryData({ geometries: place, zoom });
        this.cache.set(key, geometry);

        return geometry;
    }
}

const cache = new GeometryCache();
const geometry = await cache.getGeometry(place, 10);
```

## Error Handling

Handle cases where geometry data isn't available:

```javascript
const safeGeometryData = async (place, zoom = 10) => {
    try {
        if (!place.features || place.features.length === 0) {
            return { success: false, message: 'No place data provided' };
        }

        const geometry = await geometryData({ geometries: place, zoom });

        if (!geometry.features || geometry.features.length === 0) {
            return {
                success: false,
                message: 'No geometry data available for this place'
            };
        }

        return { success: true, geometry };

    } catch (error) {
        return {
            success: false,
            message: `Geometry data request failed: ${error.message}`
        };
    }
};
```

## Best Practices

1. **Choose appropriate zoom levels**: Higher zoom = more detail but larger file sizes
2. **Cache geometries**: Store frequently accessed boundaries to reduce API calls
3. **Batch requests**: Process multiple geometries together when possible
4. **Handle missing data**: Not all places have detailed boundary information
5. **Consider file sizes**: High-detail geometries can be large - optimize for your use case
6. **Combine with search**: Use search results as input for geometry data requests
