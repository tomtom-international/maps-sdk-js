---
title: Route sections
hideMenu: false
hideSubmenu: false
hasTwoColumns: false
titleTags:
- label: "VERSION 0.9.3"
  color: "grey5"
- label: "PRIVATE PREVIEW"
  color: "grey5"
---

# Route Sections Overview

Route sections in the TomTom Maps SDK provide detailed information about specific segments of a calculated route. These sections identify different characteristics along the route path, such as traffic incidents, toll roads, ferries, tunnels, and country boundaries, enabling applications to provide detailed route analysis and user guidance.

## Purpose and Functionality

Route sections enable you to:
- **Identify route characteristics** such as toll roads, ferries, and traffic incidents
- **Analyze route segments** with specific properties like travel modes and road types
- **Provide detailed user information** about what to expect along the route
- **Calculate costs and times** for specific route segments
- **Implement route-specific logic** based on section properties

## Core Section Concepts

### Section Structure
All route sections share common properties that define their position within the route:

```typescript
interface RouteSection {
    startPointIndex: number;  // Route point where section starts
    endPointIndex: number;    // Route point where section ends
    // Additional properties vary by section type
}
```

### Section Types Overview
Sections are categorized by their characteristics and the information they provide:

**Navigation Sections:**
- `leg` - Route segments between waypoints
- `traffic` - Areas with traffic incidents or congestion
- `travelMode` - Sections with specific travel modes

**Infrastructure Sections:**
- `tollRoad` - Toll road segments
- `ferry` - Ferry crossings
- `motorway` - Highway/freeway sections
- `tunnel` - Tunnel segments
- `carTrain` - Car transport train sections

**Geographic Sections:**
- `country` - Country boundary crossings
- `tollVignette` - Toll vignette required areas
- `urban` - Urban area sections

**Road Characteristic Sections:**
- `pedestrian` - Pedestrian-only areas
- `carpool` - HOV/carpool lane sections
- `unpaved` - Unpaved road sections

## Requesting Route Sections

### Basic Section Request

```typescript
import { calculateRoute } from '@cet/maps-sdk-js/services';
import { geocode } from '@cet/maps-sdk-js/services';

async function getRouteWithSections() {
    const origin = (await geocode({ query: 'Amsterdam, Netherlands' })).features[0];
    const destination = (await geocode({ query: 'Paris, France' })).features[0];

    const routeResult = await calculateRoute({
        geoInputs: [origin, destination],
        routeType: 'fastest',
        traffic: true,

        // Request specific section types
        sectionType: 'traffic',        // Include traffic sections

        // Additional route configuration
        instructionsType: 'text',
        computeTravelTimeFor: 'all'
    });

    const route = routeResult.routes[0];
    console.log('Route calculated with sections:');
    console.log(`Total sections: ${route.sections?.length || 0}`);

    return routeResult;
}
```

### Multiple Section Types

```typescript
// Request multiple types of sections
const comprehensiveRoute = await calculateRoute({
    geoInputs: [origin, destination],
    routeType: 'fastest',
    traffic: true,

    // Note: sectionType parameter may accept multiple types
    // Check API documentation for current syntax
    sectionType: 'traffic',     // Primary section type

    // Route characteristics that generate sections
    avoidTolls: false,          // Allow toll roads (creates tollRoad sections)
    avoidFerries: false,        // Allow ferries (creates ferry sections)

    computeTravelTimeFor: 'all'
});
```

## Section Type Details and Examples

### Leg Sections

Leg sections represent route segments between waypoints:

```typescript
function analyzeLegSections(routeResult: any) {
    const route = routeResult.routes[0];

    if (route.sections) {
        const legSections = route.sections.filter(section => section.sectionType === 'leg');

        legSections.forEach((legSection, index) => {
            console.log(`Leg ${index + 1}:`);
            console.log(`  Start point: ${legSection.startPointIndex}`);
            console.log(`  End point: ${legSection.endPointIndex}`);

            if (legSection.summary) {
                console.log(`  Distance: ${(legSection.summary.lengthInMeters / 1000).toFixed(1)} km`);
                console.log(`  Time: ${Math.round(legSection.summary.travelTimeInSeconds / 60)} min`);
                console.log(`  Traffic delay: ${Math.round((legSection.summary.trafficDelayInSeconds || 0) / 60)} min`);
            }
        });
    }
}
```

### Traffic Sections

Traffic sections provide detailed information about traffic incidents and delays:

```typescript
function analyzeTrafficSections(routeResult: any) {
    const route = routeResult.routes[0];

    if (route.sections) {
        const trafficSections = route.sections.filter(section => section.sectionType === 'traffic');

        trafficSections.forEach((trafficSection, index) => {
            console.log(`Traffic Incident ${index + 1}:`);
            console.log(`  Location: Points ${trafficSection.startPointIndex} to ${trafficSection.endPointIndex}`);

            if (trafficSection.incidentCategory) {
                console.log(`  Category: ${trafficSection.incidentCategory}`);
            }

            if (trafficSection.delayInSeconds) {
                console.log(`  Delay: ${Math.round(trafficSection.delayInSeconds / 60)} minutes`);
            }

            if (trafficSection.magnitude !== undefined) {
                const magnitudes = { 0: 'Unknown', 1: 'Minor', 2: 'Moderate', 3: 'Major' };
                console.log(`  Magnitude: ${magnitudes[trafficSection.magnitude] || 'Unknown'}`);
            }

            if (trafficSection.effectiveSpeedInKmh) {
                console.log(`  Effective speed: ${trafficSection.effectiveSpeedInKmh} km/h`);
            }
        });
    }
}
```

### Infrastructure Sections

```typescript
function analyzeInfrastructureSections(routeResult: any) {
    const route = routeResult.routes[0];

    if (route.sections) {
        // Toll road sections
        const tollSections = route.sections.filter(section => section.sectionType === 'tollRoad');
        console.log(`Toll road sections: ${tollSections.length}`);

        // Ferry sections
        const ferrySections = route.sections.filter(section => section.sectionType === 'ferry');
        console.log(`Ferry crossings: ${ferrySections.length}`);
        ferrySections.forEach((ferry, index) => {
            console.log(`  Ferry ${index + 1}: Points ${ferry.startPointIndex}-${ferry.endPointIndex}`);
        });

        // Tunnel sections
        const tunnelSections = route.sections.filter(section => section.sectionType === 'tunnel');
        console.log(`Tunnel sections: ${tunnelSections.length}`);

        // Motorway sections
        const motorwaySections = route.sections.filter(section => section.sectionType === 'motorway');
        console.log(`Motorway sections: ${motorwaySections.length}`);
    }
}
```

### Country and Toll Vignette Sections

```typescript
function analyzeGeographicSections(routeResult: any) {
    const route = routeResult.routes[0];

    if (route.sections) {
        // Country sections
        const countrySections = route.sections.filter(section => section.sectionType === 'country');
        console.log('Countries crossed:');
        countrySections.forEach((countrySection, index) => {
            console.log(`  ${index + 1}. ${countrySection.country} (Points ${countrySection.startPointIndex}-${countrySection.endPointIndex})`);
        });

        // Toll vignette sections
        const vignetteSections = route.sections.filter(section => section.sectionType === 'tollVignette');
        console.log('Toll vignette required in:');
        vignetteSections.forEach((vignetteSection, index) => {
            console.log(`  ${index + 1}. ${vignetteSection.country} (Points ${vignetteSection.startPointIndex}-${vignetteSection.endPointIndex})`);
        });
    }
}
```

## Section Analysis and Utilities

### Comprehensive Section Analysis

```typescript
function comprehensiveSectionAnalysis(routeResult: any) {
    const route = routeResult.routes[0];

    if (!route.sections) {
        console.log('No route sections available');
        return;
    }

    const analysis = {
        totalSections: route.sections.length,
        sectionTypes: {},
        totalDistance: route.summary.lengthInMeters / 1000,
        totalTime: route.summary.travelTimeInSeconds / 60,

        // Infrastructure summary
        infrastructure: {
            tollRoads: 0,
            ferries: 0,
            tunnels: 0,
            motorways: 0,
            unpaved: 0
        },

        // Geographic summary
        geographic: {
            countries: new Set(),
            vignetteRequired: new Set(),
            urbanAreas: 0
        },

        // Traffic summary
        traffic: {
            incidents: 0,
            totalDelay: 0,
            majorIncidents: 0
        }
    };

    route.sections.forEach(section => {
        // Count section types
        analysis.sectionTypes[section.sectionType] =
            (analysis.sectionTypes[section.sectionType] || 0) + 1;

        // Analyze infrastructure
        switch (section.sectionType) {
            case 'tollRoad':
                analysis.infrastructure.tollRoads++;
                break;
            case 'ferry':
                analysis.infrastructure.ferries++;
                break;
            case 'tunnel':
                analysis.infrastructure.tunnels++;
                break;
            case 'motorway':
                analysis.infrastructure.motorways++;
                break;
            case 'unpaved':
                analysis.infrastructure.unpaved++;
                break;
            case 'urban':
                analysis.geographic.urbanAreas++;
                break;
            case 'country':
                if (section.country) {
                    analysis.geographic.countries.add(section.country);
                }
                break;
            case 'tollVignette':
                if (section.country) {
                    analysis.geographic.vignetteRequired.add(section.country);
                }
                break;
            case 'traffic':
                analysis.traffic.incidents++;
                if (section.delayInSeconds) {
                    analysis.traffic.totalDelay += section.delayInSeconds;
                }
                if (section.magnitude === 3) {
                    analysis.traffic.majorIncidents++;
                }
                break;
        }
    });

    console.log('Route Section Analysis:', {
        ...analysis,
        geographic: {
            ...analysis.geographic,
            countries: Array.from(analysis.geographic.countries),
            vignetteRequired: Array.from(analysis.geographic.vignetteRequired)
        },
        traffic: {
            ...analysis.traffic,
            totalDelayMinutes: Math.round(analysis.traffic.totalDelay / 60)
        }
    });

    return analysis;
}
```

### Section-Based Route Warnings

```typescript
function generateRouteWarnings(routeResult: any): string[] {
    const warnings: string[] = [];
    const route = routeResult.routes[0];

    if (!route.sections) {
        return warnings;
    }

    route.sections.forEach(section => {
        switch (section.sectionType) {
            case 'tollRoad':
                warnings.push('âš ï¸ Route includes toll roads');
                break;
            case 'ferry':
                warnings.push('ðŸš¢ Route includes ferry crossings');
                break;
            case 'unpaved':
                warnings.push('ðŸ›£ï¸ Route includes unpaved roads');
                break;
            case 'traffic':
                if (section.magnitude === 3) {
                    warnings.push('ðŸš¨ Major traffic incident on route');
                } else if (section.delayInSeconds && section.delayInSeconds > 300) {
                    warnings.push('â° Significant traffic delays expected');
                }
                break;
            case 'tollVignette':
                warnings.push(`ðŸŽ« Toll vignette required in ${section.country}`);
                break;
            case 'carTrain':
                warnings.push('ðŸš‚ Route includes car train transport');
                break;
        }
    });

    // Remove duplicates
    return [...new Set(warnings)];
}

// Usage
const routeResult = await getRouteWithSections();
const warnings = generateRouteWarnings(routeResult);
warnings.forEach(warning => console.log(warning));
```

## Section-Based Route Costs

### Calculating Route Costs from Sections

```typescript
interface RouteCosts {
    tollCosts: number;
    vignetteCosts: number;
    ferryCosts: number;
    totalAdditionalCosts: number;
    currency: string;
}

function calculateRouteCosts(routeResult: any, costRates: any): RouteCosts {
    const route = routeResult.routes[0];
    const costs: RouteCosts = {
        tollCosts: 0,
        vignetteCosts: 0,
        ferryCosts: 0,
        totalAdditionalCosts: 0,
        currency: 'EUR'
    };

    if (route.sections) {
        route.sections.forEach(section => {
            const sectionDistance = calculateSectionDistance(route, section);

            switch (section.sectionType) {
                case 'tollRoad':
                    costs.tollCosts += costRates.tollPerKm * sectionDistance;
                    break;
                case 'ferry':
                    costs.ferryCosts += costRates.ferryFlat || 0;
                    break;
                case 'tollVignette':
                    // Vignette costs are usually per country, not per section
                    if (section.country && costRates.vignettes[section.country]) {
                        costs.vignetteCosts += costRates.vignettes[section.country];
                    }
                    break;
            }
        });
    }

    costs.totalAdditionalCosts = costs.tollCosts + costs.vignetteCosts + costs.ferryCosts;
    return costs;
}

function calculateSectionDistance(route: any, section: any): number {
    // Calculate distance between section start and end points
    // This is a simplified calculation - actual implementation would
    // sum distances between consecutive route points
    const totalDistance = route.summary.lengthInMeters / 1000;
    const totalPoints = route.legs?.reduce((sum, leg) => sum + (leg.points?.length || 0), 0) || 0;
    const sectionPoints = section.endPointIndex - section.startPointIndex;

    return (sectionPoints / totalPoints) * totalDistance;
}
```

## Integration with Map Display

### Highlighting Route Sections

```typescript
import { TomTomMap, RoutingModule } from '@cet/maps-sdk-js/map';

async function displayRouteWithSectionHighlights() {
    const map = new TomTomMap({
        container: 'map',
        center: [4.9041, 52.3676],
        zoom: 8
    });

    const routingModule = await RoutingModule.init(map);

    // Calculate route with sections
    const routeResult = await getRouteWithSections();

    // Display main route
    await routingModule.showRoutes(routeResult);

    // Highlight specific sections (conceptual - actual implementation may vary)
    highlightRouteSections(map, routeResult);

    return { map, routingModule, routeResult };
}

function highlightRouteSections(map: TomTomMap, routeResult: any) {
    const route = routeResult.routes[0];

    if (route.sections) {
        route.sections.forEach(section => {
            if (section.sectionType === 'tollRoad') {
                // Highlight toll sections in orange
                console.log(`Highlighting toll section: ${section.startPointIndex}-${section.endPointIndex}`);
            } else if (section.sectionType === 'ferry') {
                // Highlight ferry sections in blue
                console.log(`Highlighting ferry section: ${section.startPointIndex}-${section.endPointIndex}`);
            } else if (section.sectionType === 'traffic' && section.magnitude >= 2) {
                // Highlight traffic sections in red
                console.log(`Highlighting traffic section: ${section.startPointIndex}-${section.endPointIndex}`);
            }
        });
    }
}
```

## Best Practices

### Section Analysis Strategy
- **Request appropriate sections**: Only request section types you'll actually use
- **Handle missing sections**: Not all routes will have all section types
- **Cache analysis results**: Store section analysis to avoid repeated calculations
- **Combine with route summary**: Use sections to enhance overall route information

### Performance Considerations
- **Limit section processing**: Focus on sections relevant to your use case
- **Efficient filtering**: Use array methods efficiently when processing many sections
- **Lazy evaluation**: Calculate section-based data only when needed

### User Experience
- **Clear section indicators**: Use appropriate icons and colors for different section types
- **Contextual warnings**: Show section-based warnings at relevant times
- **Cost transparency**: Clearly communicate additional costs from toll/vignette sections

## Related Guides

- [Planning a Route](/javascript/maps/documentation/guides/services/routing/planning-a-route) - Basic route calculation
- [Waypoints and Custom Routes](/javascript/maps/documentation/guides/services/routing/waypoints-and-custom-routes) - Multi-waypoint routing
- [Planning Criteria](/javascript/maps/documentation/guides/services/routing/planning-criteria) - Route optimization options
- [Routes Module](/javascript/maps/documentation/guides/map/routes) - Displaying routes on maps

## Complete Section Analysis Example

```typescript
import { TomTomConfig } from '@cet/maps-sdk-js/core';
import { calculateRoute, geocode } from '@cet/maps-sdk-js/services';

TomTomConfig.instance.put({ apiKey: 'YOUR_API_KEY' });

async function comprehensiveRouteWithSections() {
    try {
        // Calculate long-distance route likely to have multiple section types
        const origin = (await geocode({ query: 'London, UK' })).features[0];
        const destination = (await geocode({ query: 'Rome, Italy' })).features[0];

        const routeResult = await calculateRoute({
            geoInputs: [origin, destination],
            routeType: 'fastest',
            traffic: true,

            // Enable sections
            sectionType: 'traffic',

            // Allow various route types
            avoidTolls: false,
            avoidFerries: false,

            // Get detailed information
            instructionsType: 'text',
            computeTravelTimeFor: 'all'
        });

        // Analyze sections
        const analysis = comprehensiveSectionAnalysis(routeResult);

        // Generate warnings
        const warnings = generateRouteWarnings(routeResult);

        // Calculate costs (example rates)
        const costRates = {
            tollPerKm: 0.15,        // â‚¬0.15 per km for tolls
            ferryFlat: 25.00,       // â‚¬25 flat rate for ferries
            vignettes: {            // Vignette costs per country
                'AUT': 9.60,        // Austria
                'CHE': 40.00,       // Switzerland
                'SVN': 15.00        // Slovenia
            }
        };
        const costs = calculateRouteCosts(routeResult, costRates);

        console.log('Complete Route Analysis:');
        console.log('Sections:', analysis);
        console.log('Warnings:', warnings);
        console.log('Costs:', costs);

        return { routeResult, analysis, warnings, costs };

    } catch (error) {
        console.error('Route section analysis failed:', error);
        throw error;
    }
}

// Execute comprehensive analysis
comprehensiveRouteWithSections();
```
