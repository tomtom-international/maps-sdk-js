---
title: Long Distance EV Routing
hideMenu: false
hideSubmenu: false
hasTwoColumns: false
titleTags:
- label: "VERSION 0.9.3"
  color: "grey5"
- label: "PRIVATE PREVIEW"
  color: "grey5"
---

# Long Distance EV Routing Overview

Long Distance Electric Vehicle (EV) Routing in the TomTom Maps SDK provides specialized routing capabilities for electric vehicles on extended journeys. This service calculates optimal routes that account for battery consumption, charging station locations, and charging time requirements to ensure successful long-distance travel.

## Purpose and Functionality

Long Distance EV Routing addresses the unique challenges of electric vehicle travel:
- **Range anxiety mitigation**: Ensures routes include necessary charging stops
- **Charging infrastructure integration**: Incorporates real-time charging station data
- **Battery consumption modeling**: Accounts for vehicle-specific energy consumption
- **Multi-modal optimization**: Balances travel time, charging time, and route efficiency
- **Real-time adaptation**: Adjusts routes based on current battery levels and charging availability

## Core Concepts

### EV Routing Challenges
Electric vehicles face specific routing requirements that differ from conventional vehicles:

**Range Limitations:**
- Limited driving range compared to internal combustion engines
- Battery degradation affecting actual vs. theoretical range
- Weather and terrain impact on energy consumption

**Charging Infrastructure:**
- Varying charging station availability and reliability
- Different charging speeds (Level 1, 2, DC Fast Charging)
- Network compatibility (Tesla Supercharger, CCS, CHAdeMO)
- Real-time availability and operational status

**Route Planning Complexity:**
- Multi-stop routing with charging waypoints
- Time optimization including charging duration
- Alternative route planning for charging station failures

### EV-Specific Parameters

```typescript
// EV routing requires vehicle-specific parameters
interface EVVehicleParameters {
    vehicleEngineType: 'electric';
    constantSpeedConsumptionInkWhPerHundredKm: {
        [speed: string]: number; // e.g., "50": 15.5 (kWh per 100km at 50 km/h)
    };
    currentChargeInkWh: number;        // Current battery charge
    maxChargeInkWh: number;            // Maximum battery capacity
    auxiliaryPowerInkW?: number;       // Power consumption for heating/AC
}
```

## Basic EV Routing Implementation

### Simple Long Distance EV Route

```typescript
import { TomTomConfig } from '@cet/maps-sdk-js/core';
import { calculateRoute } from '@cet/maps-sdk-js/services';
import { geocode } from '@cet/maps-sdk-js/services';

TomTomConfig.instance.put({ apiKey: 'YOUR_API_KEY' });

// Define EV parameters for a typical electric vehicle
const evVehicleParams = {
    vehicleEngineType: 'electric' as const,
    constantSpeedConsumptionInkWhPerHundredKm: {
        "10": 12.0,
        "30": 14.5,
        "50": 15.5,
        "70": 17.2,
        "90": 19.8,
        "120": 24.5
    },
    currentChargeInkWh: 65,  // Current battery level
    maxChargeInkWh: 85,      // Battery capacity
    auxiliaryPowerInkW: 2.5   // AC/heating consumption
};

async function calculateLongDistanceEVRoute() {
    // Define long-distance waypoints
    const origin = (await geocode({ query: 'Amsterdam, Netherlands' })).features[0];
    const destination = (await geocode({ query: 'Munich, Germany' })).features[0];

    const routeResult = await calculateRoute({
        geoInputs: [origin, destination],
        vehicleEngineType: evVehicleParams.vehicleEngineType,
        constantSpeedConsumptionInkWhPerHundredKm: evVehicleParams.constantSpeedConsumptionInkWhPerHundredKm,
        currentChargeInkWh: evVehicleParams.currentChargeInkWh,
        maxChargeInkWh: evVehicleParams.maxChargeInkWh,
        auxiliaryPowerInkW: evVehicleParams.auxiliaryPowerInkW
    });

    return routeResult;
}
```

### EV Route with Charging Stations

```typescript
// Calculate route with charging station information
async function calculateEVRouteWithCharging() {
    const routeResult = await calculateRoute({
        geoInputs: [origin, destination],
        vehicleEngineType: 'electric',
        constantSpeedConsumptionInkWhPerHundredKm: {
            "50": 15.5,
            "80": 18.2,
            "120": 24.5
        },
        currentChargeInkWh: 45,      // Starting with partial charge
        maxChargeInkWh: 85,
        auxiliaryPowerInkW: 2.0,

        // Charging-specific parameters
        minChargeAtDestinationInkWh: 10,     // Minimum arrival charge
        minChargeAtChargingStopsInkWh: 5,    // Minimum charge before stopping

        // Route preferences
        routeType: 'eco',            // Optimize for energy efficiency
        traffic: true,               // Account for traffic conditions
        departureTime: new Date()    // Current time for traffic data
    });

    return routeResult;
}
```

## Advanced EV Routing Features

### Multi-Stop EV Journey Planning

```typescript
// Plan a multi-stop journey with charging optimization
async function planMultiStopEVJourney() {
    const waypoints = [
        (await geocode({ query: 'Berlin, Germany' })).features[0],
        (await geocode({ query: 'Prague, Czech Republic' })).features[0],
        (await geocode({ query: 'Vienna, Austria' })).features[0],
        (await geocode({ query: 'Budapest, Hungary' })).features[0]
    ];

    const routeResult = await calculateRoute({
        geoInputs: waypoints,
        vehicleEngineType: 'electric',
        constantSpeedConsumptionInkWhPerHundredKm: {
            "30": 14.0,
            "50": 15.5,
            "80": 18.0,
            "120": 25.0
        },
        currentChargeInkWh: 80,
        maxChargeInkWh: 90,

        // Multi-stop optimization
        routeType: 'fastest',
        computeTravelTimeFor: 'all',
        traffic: true,

        // EV-specific constraints
        minChargeAtDestinationInkWh: 15,
        minChargeAtChargingStopsInkWh: 8
    });

    return routeResult;
}
```

### Weather and Terrain Considerations

```typescript
// Account for challenging conditions affecting battery consumption
async function calculateWinterEVRoute() {
    const routeResult = await calculateRoute({
        geoInputs: [origin, destination],
        vehicleEngineType: 'electric',

        // Adjusted consumption for winter conditions
        constantSpeedConsumptionInkWhPerHundredKm: {
            "30": 16.5,  // +15% consumption due to cold weather
            "50": 18.0,  // +15% consumption
            "80": 21.0,  // +15% consumption
            "120": 28.0  // +15% consumption
        },

        currentChargeInkWh: 75,
        maxChargeInkWh: 85,
        auxiliaryPowerInkW: 5.0,    // Increased heating consumption

        // More conservative charging strategy
        minChargeAtDestinationInkWh: 20,
        minChargeAtChargingStopsInkWh: 10,

        // Route preferences for safety
        routeType: 'eco',
        avoidTolls: false,    // Prefer major highways with more charging stations
        avoidMotorways: false
    });

    return routeResult;
}
```

## EV Route Analysis

### Analyzing EV Route Results

```typescript
// Analyze and interpret EV routing results
function analyzeEVRoute(routeResult: any) {
    const route = routeResult.routes[0];

    console.log('EV Route Analysis:');
    console.log(`Total Distance: ${(route.summary.lengthInMeters / 1000).toFixed(1)} km`);
    console.log(`Total Travel Time: ${Math.round(route.summary.travelTimeInSeconds / 3600)} hours`);

    // Analyze charging stops
    if (route.legs) {
        let totalChargingTime = 0;
        let chargingStops = 0;

        route.legs.forEach((leg: any, index: number) => {
            if (leg.chargingInformationAtEndOfLeg) {
                chargingStops++;
                const chargingTime = leg.chargingInformationAtEndOfLeg.chargingTimeInMinutes;
                totalChargingTime += chargingTime;

                console.log(`Charging Stop ${chargingStops}:`);
                console.log(`  - Charging Time: ${chargingTime} minutes`);
                console.log(`  - Battery After Charging: ${leg.chargingInformationAtEndOfLeg.targetChargeInkWh} kWh`);
            }
        });

        console.log(`Total Charging Stops: ${chargingStops}`);
        console.log(`Total Charging Time: ${Math.round(totalChargingTime / 60)} hours ${totalChargingTime % 60} minutes`);
        console.log(`Journey + Charging Time: ${Math.round((route.summary.travelTimeInSeconds + totalChargingTime * 60) / 3600)} hours`);
    }

    // Energy consumption analysis
    if (route.summary.batteryConsumptionInkWh) {
        console.log(`Total Energy Consumption: ${route.summary.batteryConsumptionInkWh.toFixed(1)} kWh`);
        console.log(`Energy Efficiency: ${(route.summary.batteryConsumptionInkWh / (route.summary.lengthInMeters / 100000)).toFixed(1)} kWh/100km`);
    }
}

// Usage
const evRoute = await calculateLongDistanceEVRoute();
analyzeEVRoute(evRoute);
```

## Integration with Map Display

### Displaying EV Route with Charging Information

```typescript
import { TomTomMap, RoutingModule } from '@cet/maps-sdk-js/map';
import { Marker, Popup } from 'maplibre-gl';

async function displayEVRouteWithChargingStops() {
    // Create map
    const map = new TomTomMap({
        container: 'map',
        center: [10.0, 51.5], // Germany center
        zoom: 6
    });

    // Calculate EV route
    const evRoute = await calculateLongDistanceEVRoute();

    // Display route
    const routingModule = await RoutingModule.init(map);
    await routingModule.showRoutes(evRoute);

    // Add charging station markers
    const route = evRoute.routes[0];
    if (route.legs) {
        route.legs.forEach((leg: any, index: number) => {
            if (leg.chargingInformationAtEndOfLeg && leg.points && leg.points.length > 0) {
                const lastPoint = leg.points[leg.points.length - 1];

                // Create charging station marker
                const chargingMarker = new Marker({
                    color: '#00FF00' // Green for charging stations
                })
                .setLngLat([lastPoint.longitude, lastPoint.latitude])
                .setPopup(new Popup().setHTML(`
                    <div>
                        <h3>⚡ Charging Stop ${index + 1}</h3>
                        <p><strong>Charging Time:</strong> ${leg.chargingInformationAtEndOfLeg.chargingTimeInMinutes} min</p>
                        <p><strong>Battery Level:</strong> ${leg.chargingInformationAtEndOfLeg.targetChargeInkWh} kWh</p>
                    </div>
                `))
                .addTo(map.mapLibreMap);
            }
        });
    }
}
```

## Best Practices

### Vehicle Parameter Accuracy
- **Use manufacturer data**: Get accurate consumption values from vehicle specifications
- **Account for real-world conditions**: Adjust consumption for weather, terrain, and driving style
- **Regular calibration**: Update parameters based on actual vehicle performance

### Route Planning Strategy
- **Conservative estimates**: Plan for higher consumption than theoretical values
- **Buffer charging**: Maintain minimum charge levels for safety and unexpected delays
- **Alternative planning**: Always have backup charging stations identified

### User Experience
- **Clear communication**: Show charging stops, times, and battery levels clearly
- **Real-time updates**: Update routes based on current traffic and charging station status
- **Flexibility**: Allow users to adjust charging preferences and constraints

## Related Guides

- [Planning a Route](/javascript/maps/documentation/guides/services/routing/planning-a-route) - Basic routing concepts
- [Waypoints and Custom Routes](/javascript/maps/documentation/guides/services/routing/waypoints-and-custom-routes) - Advanced waypoint management
- [Planning Criteria](/javascript/maps/documentation/guides/services/routing/planning-criteria) - Route optimization options
- [Routes Module](/javascript/maps/documentation/guides/map/routes) - Displaying routes on maps

## Complete EV Routing Example

```typescript
import { TomTomConfig } from '@cet/maps-sdk-js/core';
import { TomTomMap, RoutingModule } from '@cet/maps-sdk-js/map';
import { calculateRoute, geocode } from '@cet/maps-sdk-js/services';
import { Marker, Popup } from 'maplibre-gl';

// Initialize SDK
TomTomConfig.instance.put({ apiKey: 'YOUR_API_KEY' });

class EVRoutingManager {
    private map: TomTomMap;
    private routingModule: RoutingModule;

    async initialize() {
        // Create map
        this.map = new TomTomMap({
            container: 'map',
            center: [8.5, 50.1], // Central Europe
            zoom: 5
        });

        this.routingModule = await RoutingModule.init(this.map);
    }

    async planEVJourney(originQuery: string, destinationQuery: string) {
        // Geocode locations
        const origin = (await geocode({ query: originQuery })).features[0];
        const destination = (await geocode({ query: destinationQuery })).features[0];

        // Calculate EV route
        const routeResult = await calculateRoute({
            geoInputs: [origin, destination],
            vehicleEngineType: 'electric',
            constantSpeedConsumptionInkWhPerHundredKm: {
                "30": 14.5,
                "50": 15.8,
                "80": 18.5,
                "120": 25.2
            },
            currentChargeInkWh: 70,
            maxChargeInkWh: 85,
            auxiliaryPowerInkW: 2.5,
            minChargeAtDestinationInkWh: 15,
            minChargeAtChargingStopsInkWh: 8,
            routeType: 'eco',
            traffic: true,
            departureTime: new Date()
        });

        // Display route
        await this.routingModule.showRoutes(routeResult);

        // Add charging station markers
        this.addChargingStationMarkers(routeResult);

        // Analyze and log route information
        this.analyzeRoute(routeResult);

        return routeResult;
    }

    private addChargingStationMarkers(routeResult: any) {
        const route = routeResult.routes[0];
        if (!route.legs) return;

        route.legs.forEach((leg: any, index: number) => {
            if (leg.chargingInformationAtEndOfLeg && leg.points?.length > 0) {
                const lastPoint = leg.points[leg.points.length - 1];

                new Marker({ color: '#00FF00' })
                    .setLngLat([lastPoint.longitude, lastPoint.latitude])
                    .setPopup(new Popup().setHTML(`
                        <div>
                            <h3>⚡ Charging Stop ${index + 1}</h3>
                            <p><strong>Charging Time:</strong> ${leg.chargingInformationAtEndOfLeg.chargingTimeInMinutes} min</p>
                            <p><strong>Target Charge:</strong> ${leg.chargingInformationAtEndOfLeg.targetChargeInkWh} kWh</p>
                        </div>
                    `))
                    .addTo(this.map.mapLibreMap);
            }
        });
    }

    private analyzeRoute(routeResult: any) {
        const route = routeResult.routes[0];
        console.log('EV Route Summary:', {
            distance: `${(route.summary.lengthInMeters / 1000).toFixed(1)} km`,
            travelTime: `${Math.round(route.summary.travelTimeInSeconds / 3600)}h ${Math.round((route.summary.travelTimeInSeconds % 3600) / 60)}m`,
            energyConsumption: route.summary.batteryConsumptionInkWh ? `${route.summary.batteryConsumptionInkWh.toFixed(1)} kWh` : 'N/A',
            chargingStops: route.legs?.filter((leg: any) => leg.chargingInformationAtEndOfLeg).length || 0
        });
    }
}

// Usage
const evManager = new EVRoutingManager();
await evManager.initialize();
await evManager.planEVJourney('Amsterdam, Netherlands', 'Munich, Germany');
```
